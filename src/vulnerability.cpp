#include "../include/vulnerability.hpp"

long double bayesVulnerability(Distribution &dist){
	return *std::max_element(dist.prob.begin(), dist.prob.end());
}

long double bayesVulnerability(Hyper &hyper){
	long double vulnerability = 0;

	for(int i = 0; i < hyper.channel->num_out; i++){
		long double MAX = hyper.inners[0][i];
		for(int j = 1; j < hyper.prior->num_el; j++){
			if(MAX < hyper.inners[j][i]){
				MAX = hyper.inners[j][i];
			}
		}
		vulnerability += (hyper.outer.prob[i]*MAX);
	}

	return vulnerability;
}

long double gVulnerability(Gain &gain){
	long double MAX;
	long double acc = 0;

	for(int i = 0; i < gain.prior->num_el; i++){
		acc += (gain.prior->prob[i] * gain.matrix[0][i]); 
	}

	MAX = acc;
	for(int i = 1; i < gain.num_act; i++){
		acc = 0;
		for(int j = 0; j < gain.prior->num_el; j++){
			acc += (gain.prior->prob[j] * gain.matrix[i][j]);
		}

		if(acc > MAX){
			MAX = acc;
		}
	}

	return MAX;
}

long double gVulnerability(Hyper &hyper, Gain &gain){

	if(hyper.prior != gain.prior){
		fprintf(stderr, "The prior distribution from channel and actions are not the same!\n");
		exit(EXIT_FAILURE);
	}

	long double vulnerability = 0;

	for(int i = 0; i < hyper.channel->num_out; i++){
		/* For each posterior distribution.*/

		long double MAX = -1;
		for(int k = 0; k < gain.num_act; k++){
			/* For each action k.*/

			long double acc = 0;
			for(int j = 0; j < hyper.prior->num_el; j++){
				/* For each secret j.*/
				acc += (hyper.inners[j][i] * gain.matrix[k][j]);
			}

			if(acc > MAX){
				MAX = acc;
			}
		}
		
		vulnerability += (hyper.outer.prob[i] * MAX);
	}

	return vulnerability;
}

long double kTries(Distribution &dist, int k){
	long double S = 0;

	std::vector<long double> ordered_distribution = dist.prob;
	std::sort(ordered_distribution.rbegin(), ordered_distribution.rend());

	for(int i = 0; i < k; i++){
		S += ordered_distribution[i];
	}

	return S;
}

long double kTries(Hyper &hyper, int k){
	long double S = 0;

	for(int i = 0; i < hyper.channel->num_out; i++){
		/* For each posterior distribution.*/
		
		std::vector<long double> ordered_d;
		
		for(int j = 0; j < hyper.prior->num_el; j++){
			ordered_d.push_back(hyper.inners[j][i]);
		}

		std::sort(ordered_d.rbegin(), ordered_d.rend());

		long double pS = 0;
		for(int j = 0; j < k; j++){
			pS += ordered_d[j];
		}

		S += (hyper.outer.prob[i] * pS);
	}

	return S;
}
